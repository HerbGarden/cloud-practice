ps

STAT
S : cpu자원을 기다리고 있는 상태
T : 중단된 상태
R : 실행 혹은 곧 실행 되는 상태
Z : 좀비 상태

unix 계열
System V 계열 - solaris, ibm-AIM, ...redhat
BSD 계열 - freebasd, openbsd

옵션 보기
 -유닉스 옵션 : -e. -f 같이 붙은 것
 -bsd 옵셥 : a, u 
 -gnu 옵션 : -- 들어간 것

$() - ()안에 명령어를 실행해줌 = ``

` - back quatation

ps -o 옵션을 주고 원하는 행을 써주면 보여줌
	ex) ps -o uid, pid.cmd

kill - 프로세스에게 시그널을 보냄
	-9 강제 종료(죽임)
	-15 defaul 값 종료
	-18 대기중인 프로세스 실행
	-19 실행중인 프로세스 중단
	-3 코어 덤프 발생 시키기 

보통 자식 프로세스가 실행중에 부모 프로세스가 죽으면 자식 프로세스도 같이 죽지만
요즘 리눅스는 1프로세스가 자식 프로세스를 받아 계속 실행된다.

ulimit -a : 저장 파일에 최대치를 보여줌

pkill - 프로세스의 명령 이름으로 kill명령 실행

작업예약 스케쥴

인터넷 시간과 동기화 하는 법
rdate -s time.bora.net
rdate -s 다른 서버 : 다른 서버 시간과 동기화

수동으로 시간 변경법
date 월일시간분 을 써주면 됨

cron - 일정한 주기마다 실행될 작업 예약

daemon == server

at - 예약한 시간에 명령
atq - 예약한 명령 확인 - 자신이 한 명령어만 확인 가능 (root만 다 볼수 있음)
atrm - 예약 삭제
at 명령 제한 하기
/etc 밑에 at.deny - 못쓰게 하기, at.allow - 허용 하기
		ㄴ파일 작성시 한줄에 한 유저만 작성해야 됨

에디터 환경 변경하기
export EDITOR=vim

crontab - 일정 주기로 예약 명령어 실행하기
	/etc/crontab - root가 시스템에 중요한 명령을 예약할때 쓰는게 좋음
crontab -e : 보통 cron예약시 사용
crontab -l : 사용자가 예약한 내용 보기

cron 로그 보는 법
/var/log 밑에 cron에 로그가 나옴

cron 은 기본적으로 path가 usr/bin:/bin으로만 실해되기 때문에
실행 명령어에 경로를 다 적어주거나, path를 따로 명시해야 된다.
ex)
	PATH=/usr/bin:/bin:/usr/sbin
		or
	/usr/sbin/useradd

-r 삭제
-u 사용자 사용자에 것을 봄
-i 대화식으로 함

----------------------------------------------------------------------------------------------
340p연습문제

2: PID는 자신의 프로세스 ID이고 PPID는 부모 프로세스의 ID이므로 
-bash 의 자식은 sh이고 sh의 자식은 vi /etc/hosts이다.

3: ps -U guest

4: kill 에 -9 옵션을 이용하면 된다.

5: top 명령어를 실행하면 된다.

6: pkill은 프로세스 명령 이름으로 실행되므로 같은 프로세스 명령 이름이 여러개 있을때
 kill 명령을 한번에  적용할수 있어 편리하다.

7: echo "3 ^ 10000000" | bc > /tmp/result_file 입력 후 컨트롤 + z 키를 누를시 실행되고 있는
프로세스가 잠시 멈추며 그 후에 bg(kill -CONT %해당하는 번호)를 입력하면 백그라운드에서
작업이 실행된다.

8:fg %1을 입력하면 된다.

9:kill %3을 입력하면 된다.

10: 현재 리눅스는 그냥 종료해도 1번 프로세스가 이어 받아 계속 진행된다.
혹은 nohup echo "4 ^ 10000000" | bc > /tmp/result_file2 &를 이용하면 된다.

11: at는 명령어를 한번 예약할때 주로 사용하고 cron은 명령어를 주기적으로 실행할때 사용한다.

12: at.allow는 at를 사용시키고자 하는 사용자를 등록하는 것이고 at.deny이는 사용시키지 않을 
사용자를 등록하는 것이므로 guset01은 사용할 수 없다.

13: at 12:00 31.12.20 을 입력후 ps -U user01을 입력후 컨트로 d로 빠져나오면 된다.

14:user01 사용자로 로그인 되있을때 crontab -e명령어를 입력 후 0 0 * * 0 ps > ps.out 을 작성
한 뒤에 :wq로 저장하면 설정이 된다.

15:atrm 작업 번호를 입력하면 된다.

16번 문제
: user1, user2 만 crontab 사용가능하게 하고 나머지는 모두 crontab 사용금지하게 설정
(*root 는 설정과 관계없이 예외적으로 crontab 사용할수 있음)

: root로 로그인 한뒤 vim /etc/cron.allow 를 입력한 뒤 한 줄에 하나씩 user1, user2를 입력한
뒤 :wq로 저장하면 된다.

-----------------------------------------------------------------------------------------------

특수 접근 권한
 - 시스템 운용
 - 시스템 보안
setUID (--s --- ---) :4000
  - 실행하는 동안 프로세스가 소유자 권한을 가진다.
  - 대부분 실행 파일에만 설정한다.
setuid를 찾을때 : find / -perm -4000(-은 범위로 4000~4777)

set GID (--- --s ---) :2000
  - 디렉토리에 gid를 설정시 그 디렉토리 안에서 만들어진 파일은 모두 그 디렉토리의 그룹으로
만들어 진다
sticky bit (--- --- --t) :1000
  - 디렉토리에 sticky bit이 있으면 소유주를 제외하고는 파일을 삭제 할수 없다.


 -권한에 x가 있을시 소문자 s로 표시되지만 없을시 S로 표시된다.

기본 접근 권한 설정
umask
 - 최대 권한에서 umask뒤에 쓰는 이진수를 빼면 된다.
 - 일반 파일의 최대권한은 보통 666이다.
 - 디렉토리의 최대 권한은 777이다.
 - umask를 지정할때 보통 디렉토리를 기준으로 한다.
 - 복사할 때도 영향이 간다.
 - /etc/.bashrc에 디폴트가 저장 되어 있다.

bash shell 로 로그인시
1./etc/profile
2.$HOME/.bash_profile
3.$HOME/.bashrc
4./etc/bashrc
순으로 실행된다.
